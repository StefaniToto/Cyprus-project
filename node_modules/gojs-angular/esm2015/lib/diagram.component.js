/**
 * @fileoverview added by tsickle
 * Generated from: lib/diagram.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, Input, IterableDiffers, KeyValueDiffers, NgZone, Output, ViewChild } from '@angular/core';
import * as go from 'gojs';
export class DiagramComponent {
    /**
     * @param {?} _differs
     * @param {?} _kvdiffers
     * @param {?} zone
     */
    constructor(_differs, _kvdiffers, zone) {
        this._differs = _differs;
        this._kvdiffers = _kvdiffers;
        this.zone = zone;
        // Link data for diagram
        this.linkDataArray = null; // optional
        // optional
        // Model data for diagram
        this.modelData = null; // optional
        // model changed listener function for diagram
        this.modelChangedListener = null;
        this.skipsDiagramUpdate = false;
        // event emitter -- fires when diagram model changes. Capture this emitted event in parent component
        this.modelChange = new EventEmitter();
        this.diagram = null;
        // differs used to check if there have been changed to the array @Inputs
        // without them, changes to the input arrays won't register in ngOnChanges,
        // since the array reference itself may be the same
        this._ndaDiffer = this._kvdiffers.find([]).create();
        this._ldaDiffer = this._kvdiffers.find([]).create();
        // also watch if model data changes; this differ must be initialized in ngOnInit
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // initialize the differ that listens for changes to modelData object
        if (this.modelData) {
            this._mdDiffer = this._kvdiffers.find(this.modelData).create();
        }
    } // end ngOnInit
    // end ngOnInit
    /**
     * Initializes diagram / model after view init
     * @return {?}
     */
    ngAfterViewInit() {
        this.diagram = this.initDiagram();
        // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
        // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
        // If some state-altering behavior must happen on a mousemove event inside the diagram,
        // you will have to using zone.run() to make sure that event triggers angular change detection
        this.diagram.addEventListener = (/**
         * @param {?} DOMElement
         * @param {?} name
         * @param {?} listener
         * @param {?} capture
         * @return {?}
         */
        (DOMElement, name, listener, capture) => {
            /** @type {?} */
            const superAddEventListener = go.Diagram.prototype.addEventListener;
            if (name === 'mousemove') {
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => superAddEventListener.call(this, DOMElement, name, listener, capture)));
            }
            else {
                this.zone.run((/**
                 * @return {?}
                 */
                () => {
                    superAddEventListener.call(this, DOMElement, name, listener, capture);
                }));
            }
        });
        // assign the Diagram's div, which (among many other things) will attach a bunch of listeners to the canvas,
        // using the overridden addEventListener function above
        /** @type {?} */
        const divRef = this.diagramDiv.nativeElement;
        if (divRef === null)
            return;
        this.diagram.div = divRef;
        // initialize the Diagram's model
        this.diagram.delayInitialization((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const model = this.diagram.model;
            model.commit((/**
             * @param {?} m
             * @return {?}
             */
            (m) => {
                m.mergeNodeDataArray(m.cloneDeep(this.nodeDataArray));
                if (this.linkDataArray && m instanceof go.GraphLinksModel) {
                    m.mergeLinkDataArray(m.cloneDeep(this.linkDataArray));
                }
                if (this.modelData) {
                    m.assignAllDataProperties(m.modelData, this.modelData);
                }
            }), null);
        }));
        // initializer listener
        this.modelChangedListener = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (e.isTransactionFinished) {
                // this must be done within a NgZone.run block, so changes are detected in the parent component
                this.zone.run((/**
                 * @return {?}
                 */
                () => {
                    /** @type {?} */
                    const dataChanges = (/** @type {?} */ (e.model)).toIncrementalData(e);
                    this.modelChange.emit(dataChanges);
                }));
            }
        });
        this.diagram.addModelChangedListener(this.modelChangedListener);
    } // end ngAfterViewInit
    // end ngAfterViewInit
    /**
     * Always be checking if array Input data has changed (node and link data arrays)
     * @return {?}
     */
    ngDoCheck() {
        if (!this.diagram)
            return;
        if (!this.diagram.model)
            return;
        // these need to be run each check, even if no merging happens
        // otherwise, they will detect all diffs that happened since last time skipsDiagram was false,
        // such as remove ops that happened in GoJS when skipsDiagram = true, 
        // and then realllllly bad stuff happens (deleting random nodes, updating the wrong Parts)
        // Angular differs are a lot of fun
        /** @type {?} */
        var nodeDiffs = this._ndaDiffer.diff(this.nodeDataArray);
        /** @type {?} */
        var linkDiffs = this._ldaDiffer.diff(this.linkDataArray);
        if (this.skipsDiagramUpdate)
            return;
        /**
         * @param {?} obj1
         * @param {?} obj2
         * @return {?}
         */
        function compareObjs(obj1, obj2) {
            // Loop through properties in object 1
            for (const p in obj1) {
                // Check property exists on both objects
                if (obj1.hasOwnProperty(p) !== obj2.hasOwnProperty(p))
                    return false;
                switch (typeof (obj1[p])) {
                    // Deep compare objects
                    case 'object':
                        if (!compareObjs(obj1[p], obj2[p]))
                            return false;
                        break;
                    // Compare values
                    default:
                        if (obj1[p] !== obj2[p])
                            return false;
                }
            }
            // Check object 2 for any extra properties
            for (const p in obj2) {
                if (typeof (obj1[p]) === 'undefined')
                    return false;
            }
            return true;
        }
        /** @type {?} */
        var dc = this;
        // merges changes from app data into GoJS model data, 
        // making sure only actual changes (and not falsely flagged no-ops on array / obj data props) are logged
        /**
         * @param {?} kvchanges
         * @param {?} str
         * @return {?}
         */
        function mergeChanges(kvchanges, str) {
            if (!dc.diagram || !dc.diagram.model)
                return;
            if (kvchanges) {
                kvchanges.forEachAddedItem((/**
                 * @param {?} r
                 * @return {?}
                 */
                (r) => {
                    switch (str) {
                        case "n": {
                            dc.diagram.model.addNodeData(r.currentValue);
                            break;
                        }
                        case "l": {
                            /** @type {?} */
                            var m = (/** @type {?} */ (dc.diagram.model));
                            m.addLinkData(r.currentValue);
                            break;
                        }
                    }
                }));
                kvchanges.forEachRemovedItem((/**
                 * @param {?} r
                 * @return {?}
                 */
                (r) => {
                    switch (str) {
                        case "n": {
                            /** @type {?} */
                            var node = dc.diagram.findNodesByExample(r.previousValue).first();
                            dc.diagram.remove(node);
                            break;
                        }
                        case "l": {
                            /** @type {?} */
                            var link = dc.diagram.findLinksByExample(r.previousValue).first();
                            dc.diagram.remove(link);
                            break;
                        }
                    }
                }));
                kvchanges.forEachChangedItem((/**
                 * @param {?} r
                 * @return {?}
                 */
                (r) => {
                    /** @type {?} */
                    const curVal = r.currentValue;
                    /** @type {?} */
                    const pVal = r.previousValue;
                    // ensure "changes" to array / object / enumerable data properties are legit
                    /** @type {?} */
                    const sameVals = compareObjs(curVal, pVal);
                    if (!sameVals) {
                        switch (str) {
                            case "n": {
                                /** @type {?} */
                                var node = dc.diagram.findNodesByExample(r.previousValue).first();
                                dc.diagram.model.assignAllDataProperties(node.data, r.currentValue);
                                break;
                            }
                            case "l": {
                                /** @type {?} */
                                var link = dc.diagram.findLinksByExample(r.previousValue).first();
                                dc.diagram.model.assignAllDataProperties(link.data, r.currentValue);
                                break;
                            }
                        }
                    }
                }));
            }
        }
        // don't need model change listener while performing known data updates
        if (this.modelChangedListener !== null)
            this.diagram.model.removeChangedListener(this.modelChangedListener);
        this.diagram.model.startTransaction('update data');
        // var nodeDiffs = this._ndaDiffer.diff(this.nodeDataArray);
        mergeChanges(nodeDiffs, "n");
        mergeChanges(linkDiffs, "l");
        this.diagram.model.assignAllDataProperties(this.diagram.model.modelData, this.modelData);
        this.diagram.model.commitTransaction('update data');
        // reset the model change listener
        if (this.modelChangedListener !== null)
            this.diagram.model.addChangedListener(this.modelChangedListener);
    } // end ngDoCheck
}
DiagramComponent.decorators = [
    { type: Component, args: [{
                selector: 'gojs-diagram',
                template: '<div #ngDiagram [className]=divClassName></div>'
            }] }
];
/** @nocollapse */
DiagramComponent.ctorParameters = () => [
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: NgZone }
];
DiagramComponent.propDecorators = {
    initDiagram: [{ type: Input }],
    nodeDataArray: [{ type: Input }],
    linkDataArray: [{ type: Input }],
    modelData: [{ type: Input }],
    divClassName: [{ type: Input }],
    modelChangedListener: [{ type: Input }],
    skipsDiagramUpdate: [{ type: Input }],
    modelChange: [{ type: Output }],
    diagramDiv: [{ type: ViewChild, args: ['ngDiagram', { static: true },] }]
};
if (false) {
    /**
     * Diagram initialization function. Returns a go.Diagram.
     * Do not initialize model data in this function.
     * @type {?}
     */
    DiagramComponent.prototype.initDiagram;
    /** @type {?} */
    DiagramComponent.prototype.nodeDataArray;
    /** @type {?} */
    DiagramComponent.prototype.linkDataArray;
    /** @type {?} */
    DiagramComponent.prototype.modelData;
    /** @type {?} */
    DiagramComponent.prototype.divClassName;
    /** @type {?} */
    DiagramComponent.prototype.modelChangedListener;
    /** @type {?} */
    DiagramComponent.prototype.skipsDiagramUpdate;
    /** @type {?} */
    DiagramComponent.prototype.modelChange;
    /** @type {?} */
    DiagramComponent.prototype.diagramDiv;
    /** @type {?} */
    DiagramComponent.prototype.diagram;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._ndaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._ldaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._mdDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._differs;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._kvdiffers;
    /** @type {?} */
    DiagramComponent.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhZ3JhbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9nb2pzLWFuZ3VsYXIvc3JjL2xpYi9kaWFncmFtLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsZUFBZSxFQUFrQyxlQUFlLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQXdCLE1BQU0sZUFBZSxDQUFDO0FBQzlMLE9BQU8sS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBTzNCLE1BQU0sT0FBTyxnQkFBZ0I7Ozs7OztJQXVDM0IsWUFBb0IsUUFBeUIsRUFBVSxVQUEyQixFQUFTLElBQVk7UUFBbkYsYUFBUSxHQUFSLFFBQVEsQ0FBaUI7UUFBVSxlQUFVLEdBQVYsVUFBVSxDQUFpQjtRQUFTLFNBQUksR0FBSixJQUFJLENBQVE7O1FBM0J2RixrQkFBYSxHQUF5QixJQUFJLENBQUMsQ0FBQyxXQUFXOzs7UUFHdkQsY0FBUyxHQUFrQixJQUFJLENBQUMsQ0FBQyxXQUFXOztRQU01Qyx5QkFBb0IsR0FBd0MsSUFBSSxDQUFDO1FBRzFFLHVCQUFrQixHQUFZLEtBQUssQ0FBQzs7UUFHMUIsZ0JBQVcsR0FBcUMsSUFBSSxZQUFZLEVBQXNCLENBQUM7UUFHakcsWUFBTyxHQUFlLElBQUksQ0FBQztRQVVoQyx3RUFBd0U7UUFDeEUsMkVBQTJFO1FBQzNFLG1EQUFtRDtRQUNuRCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3BELElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFcEQsZ0ZBQWdGO0lBQ2xGLENBQUM7Ozs7SUFFTSxRQUFRO1FBQ2IscUVBQXFFO1FBQ3JFLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNsQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUNoRTtJQUNILENBQUMsQ0FBQyxlQUFlOzs7Ozs7SUFLVixlQUFlO1FBQ3BCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRWxDLGlHQUFpRztRQUNqRyxtSUFBbUk7UUFDbkksdUZBQXVGO1FBQ3ZGLDhGQUE4RjtRQUM5RixJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQjs7Ozs7OztRQUFHLENBQUMsVUFBdUMsRUFBRSxJQUFZLEVBQUUsUUFBYSxFQUFFLE9BQWdCLEVBQUUsRUFBRTs7a0JBQ25ILHFCQUFxQixHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLGdCQUFnQjtZQUNuRSxJQUFJLElBQUksS0FBSyxXQUFXLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCOzs7Z0JBQUMsR0FBRyxFQUFFLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsRUFBQyxDQUFDO2FBQzFHO2lCQUFNO2dCQUNMLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRzs7O2dCQUFDLEdBQUcsRUFBRTtvQkFDakIscUJBQXFCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDeEUsQ0FBQyxFQUFDLENBQUM7YUFDSjtRQUNILENBQUMsQ0FBQSxDQUFDOzs7O2NBSUksTUFBTSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYTtRQUM1QyxJQUFJLE1BQU0sS0FBSyxJQUFJO1lBQUUsT0FBTztRQUM1QixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUM7UUFFMUIsaUNBQWlDO1FBQ2pDLElBQUksQ0FBQyxPQUFPLENBQUMsbUJBQW1COzs7UUFBQyxHQUFHLEVBQUU7O2tCQUM5QixLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLO1lBQ2hDLEtBQUssQ0FBQyxNQUFNOzs7O1lBQUMsQ0FBQyxDQUFXLEVBQUUsRUFBRTtnQkFDM0IsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7Z0JBQ3RELElBQUksSUFBSSxDQUFDLGFBQWEsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLGVBQWUsRUFBRTtvQkFDekQsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7aUJBQ3ZEO2dCQUNELElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtvQkFDbEIsQ0FBQyxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2lCQUN4RDtZQUNILENBQUMsR0FBRSxJQUFJLENBQUMsQ0FBQztRQUNYLENBQUMsRUFBQyxDQUFDO1FBRUgsdUJBQXVCO1FBQ3ZCLElBQUksQ0FBQyxvQkFBb0I7Ozs7UUFBRyxDQUFDLENBQWtCLEVBQUUsRUFBRTtZQUNqRCxJQUFJLENBQUMsQ0FBQyxxQkFBcUIsRUFBRTtnQkFDM0IsK0ZBQStGO2dCQUMvRixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUc7OztnQkFBQyxHQUFHLEVBQUU7OzBCQUNYLFdBQVcsR0FBRyxtQkFBQSxDQUFDLENBQUMsS0FBSyxFQUFDLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO29CQUNqRCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDckMsQ0FBQyxFQUFDLENBQUM7YUFDSjtRQUNILENBQUMsQ0FBQSxDQUFDO1FBQ0YsSUFBSSxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUVsRSxDQUFDLENBQUMsc0JBQXNCOzs7Ozs7SUFPakIsU0FBUztRQUtkLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTztZQUFFLE9BQU87UUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSztZQUFFLE9BQU87Ozs7Ozs7WUFPNUIsU0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUM7O1lBQ3BELFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBRXhELElBQUksSUFBSSxDQUFDLGtCQUFrQjtZQUFFLE9BQU87Ozs7OztRQUVwQyxTQUFTLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSTtZQUM3QixzQ0FBc0M7WUFDdEMsS0FBSyxNQUFNLENBQUMsSUFBSSxJQUFJLEVBQUU7Z0JBQ3BCLHdDQUF3QztnQkFDeEMsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO29CQUFFLE9BQU8sS0FBSyxDQUFDO2dCQUVwRSxRQUFRLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtvQkFDeEIsdUJBQXVCO29CQUN2QixLQUFLLFFBQVE7d0JBQ1gsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDOzRCQUFFLE9BQU8sS0FBSyxDQUFDO3dCQUNqRCxNQUFNO29CQUNSLGlCQUFpQjtvQkFDakI7d0JBQ0UsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQzs0QkFBRSxPQUFPLEtBQUssQ0FBQztpQkFDekM7YUFDRjtZQUVELDBDQUEwQztZQUMxQyxLQUFLLE1BQU0sQ0FBQyxJQUFJLElBQUksRUFBRTtnQkFDcEIsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssV0FBVztvQkFBRSxPQUFPLEtBQUssQ0FBQzthQUNwRDtZQUNELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQzs7WUFFRyxFQUFFLEdBQUcsSUFBSTs7Ozs7Ozs7UUFHYixTQUFTLFlBQVksQ0FBQyxTQUFTLEVBQUUsR0FBRztZQUNsQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSztnQkFBRSxPQUFPO1lBRTdDLElBQUksU0FBUyxFQUFFO2dCQUNiLFNBQVMsQ0FBQyxnQkFBZ0I7Ozs7Z0JBQUMsQ0FBQyxDQUFvQyxFQUFFLEVBQUU7b0JBQ2xFLFFBQVEsR0FBRyxFQUFFO3dCQUNYLEtBQUssR0FBRyxDQUFDLENBQUM7NEJBQ1IsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQzs0QkFDN0MsTUFBTTt5QkFDUDt3QkFDRCxLQUFLLEdBQUcsQ0FBQyxDQUFDOztnQ0FDSixDQUFDLEdBQUcsbUJBQW9CLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFBOzRCQUM1QyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQzs0QkFDOUIsTUFBTTt5QkFDUDtxQkFDRjtnQkFDSCxDQUFDLEVBQUMsQ0FBQztnQkFDSCxTQUFTLENBQUMsa0JBQWtCOzs7O2dCQUFDLENBQUMsQ0FBb0MsRUFBRSxFQUFFO29CQUNwRSxRQUFRLEdBQUcsRUFBRTt3QkFDWCxLQUFLLEdBQUcsQ0FBQyxDQUFDOztnQ0FDSixJQUFJLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsS0FBSyxFQUFFOzRCQUNqRSxFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzs0QkFDeEIsTUFBTTt5QkFDUDt3QkFDRCxLQUFLLEdBQUcsQ0FBQyxDQUFDOztnQ0FDSixJQUFJLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsS0FBSyxFQUFFOzRCQUNqRSxFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzs0QkFDeEIsTUFBTTt5QkFDUDtxQkFDRjtnQkFDSCxDQUFDLEVBQUMsQ0FBQztnQkFFSCxTQUFTLENBQUMsa0JBQWtCOzs7O2dCQUFDLENBQUMsQ0FBb0MsRUFBRSxFQUFFOzswQkFDOUQsTUFBTSxHQUFHLENBQUMsQ0FBQyxZQUFZOzswQkFDdkIsSUFBSSxHQUFHLENBQUMsQ0FBQyxhQUFhOzs7MEJBR3RCLFFBQVEsR0FBRyxXQUFXLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQztvQkFDMUMsSUFBSSxDQUFDLFFBQVEsRUFBRTt3QkFDYixRQUFRLEdBQUcsRUFBRTs0QkFDWCxLQUFLLEdBQUcsQ0FBQyxDQUFDOztvQ0FDSixJQUFJLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsS0FBSyxFQUFFO2dDQUNqRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQztnQ0FDcEUsTUFBTTs2QkFDUDs0QkFDRCxLQUFLLEdBQUcsQ0FBQyxDQUFDOztvQ0FDSixJQUFJLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsS0FBSyxFQUFFO2dDQUNqRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQztnQ0FDcEUsTUFBTTs2QkFDUDt5QkFDRjtxQkFDRjtnQkFFSCxDQUFDLEVBQUMsQ0FBQzthQUNKO1FBRUgsQ0FBQztRQUVELHVFQUF1RTtRQUN2RSxJQUFJLElBQUksQ0FBQyxvQkFBb0IsS0FBSyxJQUFJO1lBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFFNUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDbkQsNERBQTREO1FBQzVELFlBQVksQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDN0IsWUFBWSxDQUFDLFNBQVMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUM3QixJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3pGLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3BELGtDQUFrQztRQUNsQyxJQUFJLElBQUksQ0FBQyxvQkFBb0IsS0FBSyxJQUFJO1lBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7SUFFM0csQ0FBQyxDQUFDLGdCQUFnQjs7O1lBM09uQixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGNBQWM7Z0JBQ3hCLFFBQVEsRUFBRSxpREFBaUQ7YUFDNUQ7Ozs7WUFQb0QsZUFBZTtZQUFrQyxlQUFlO1lBQUUsTUFBTTs7OzBCQWMxSCxLQUFLOzRCQUdMLEtBQUs7NEJBR0wsS0FBSzt3QkFHTCxLQUFLOzJCQUdMLEtBQUs7bUNBR0wsS0FBSztpQ0FFTCxLQUFLOzBCQUlMLE1BQU07eUJBRU4sU0FBUyxTQUFDLFdBQVcsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Ozs7Ozs7O0lBdkJ4Qyx1Q0FBOEM7O0lBRzlDLHlDQUFvRDs7SUFHcEQseUNBQTJEOztJQUczRCxxQ0FBZ0Q7O0lBR2hELHdDQUFxQzs7SUFHckMsZ0RBQWlGOztJQUVqRiw4Q0FDMkM7O0lBRzNDLHVDQUF3Rzs7SUFFeEcsc0NBQXdFOztJQUN4RSxtQ0FBa0M7Ozs7O0lBR2xDLHNDQUFnRDs7Ozs7SUFDaEQsc0NBQWdEOzs7OztJQUVoRCxxQ0FBK0M7Ozs7O0lBR25DLG9DQUFpQzs7Ozs7SUFBRSxzQ0FBbUM7O0lBQUUsZ0NBQW1CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBJdGVyYWJsZURpZmZlcnMsIEl0ZXJhYmxlRGlmZmVyLCBLZXlWYWx1ZURpZmZlciwgS2V5VmFsdWVEaWZmZXJzLCBOZ1pvbmUsIE91dHB1dCwgVmlld0NoaWxkLCBLZXlWYWx1ZUNoYW5nZVJlY29yZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgKiBhcyBnbyBmcm9tICdnb2pzJztcclxuaW1wb3J0IHsgZGFzaENhc2VUb0NhbWVsQ2FzZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy91dGlsJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnZ29qcy1kaWFncmFtJyxcclxuICB0ZW1wbGF0ZTogJzxkaXYgI25nRGlhZ3JhbSBbY2xhc3NOYW1lXT1kaXZDbGFzc05hbWU+PC9kaXY+J1xyXG59KVxyXG5leHBvcnQgY2xhc3MgRGlhZ3JhbUNvbXBvbmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERpYWdyYW0gaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24uIFJldHVybnMgYSBnby5EaWFncmFtLlxyXG4gICAqIERvIG5vdCBpbml0aWFsaXplIG1vZGVsIGRhdGEgaW4gdGhpcyBmdW5jdGlvbi5cclxuICAgKi9cclxuICBASW5wdXQoKSBwdWJsaWMgaW5pdERpYWdyYW06ICgpID0+IGdvLkRpYWdyYW07XHJcblxyXG4gIC8vIE5vZGUgZGF0YSBmb3IgZGlhZ3JhbVxyXG4gIEBJbnB1dCgpIHB1YmxpYyBub2RlRGF0YUFycmF5OiBBcnJheTxnby5PYmplY3REYXRhPjtcclxuXHJcbiAgLy8gTGluayBkYXRhIGZvciBkaWFncmFtXHJcbiAgQElucHV0KCkgcHVibGljIGxpbmtEYXRhQXJyYXk6IEFycmF5PGdvLk9iamVjdERhdGE+ID0gbnVsbDsgLy8gb3B0aW9uYWxcclxuXHJcbiAgLy8gTW9kZWwgZGF0YSBmb3IgZGlhZ3JhbVxyXG4gIEBJbnB1dCgpIHB1YmxpYyBtb2RlbERhdGE6IGdvLk9iamVjdERhdGEgPSBudWxsOyAvLyBvcHRpb25hbFxyXG5cclxuICAvLyBEaWFncmFtIGRpdiBjbGFzcyBuYW1lLiBVc2UgdGhpcyBuYW1lIHRvIHN0eWxlIHlvdXIgZGlhZ3JhbSBpbiBDU1NcclxuICBASW5wdXQoKSBwdWJsaWMgZGl2Q2xhc3NOYW1lOiBzdHJpbmc7XHJcblxyXG4gIC8vIG1vZGVsIGNoYW5nZWQgbGlzdGVuZXIgZnVuY3Rpb24gZm9yIGRpYWdyYW1cclxuICBASW5wdXQoKSBwdWJsaWMgbW9kZWxDaGFuZ2VkTGlzdGVuZXI6IChlOiBnby5DaGFuZ2VkRXZlbnQpID0+IHZvaWQgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgQElucHV0KClcclxuICBwdWJsaWMgc2tpcHNEaWFncmFtVXBkYXRlOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gIC8vIGV2ZW50IGVtaXR0ZXIgLS0gZmlyZXMgd2hlbiBkaWFncmFtIG1vZGVsIGNoYW5nZXMuIENhcHR1cmUgdGhpcyBlbWl0dGVkIGV2ZW50IGluIHBhcmVudCBjb21wb25lbnRcclxuICBAT3V0cHV0KCkgcHVibGljIG1vZGVsQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Z28uSW5jcmVtZW50YWxEYXRhPiA9IG5ldyBFdmVudEVtaXR0ZXI8Z28uSW5jcmVtZW50YWxEYXRhPigpO1xyXG5cclxuICBAVmlld0NoaWxkKCduZ0RpYWdyYW0nLCB7IHN0YXRpYzogdHJ1ZSB9KSBwdWJsaWMgZGlhZ3JhbURpdjogRWxlbWVudFJlZjtcclxuICBwdWJsaWMgZGlhZ3JhbTogZ28uRGlhZ3JhbSA9IG51bGw7XHJcblxyXG4gIC8vIGRpZmZlcnMgZm9yIGFycmF5IGlucHV0cyAobm9kZSAvIGxpbmsgZGF0YSBhcnJheXMpXHJcbiAgcHJpdmF0ZSBfbmRhRGlmZmVyOiBLZXlWYWx1ZURpZmZlcjxzdHJpbmcsIGFueT47XHJcbiAgcHJpdmF0ZSBfbGRhRGlmZmVyOiBLZXlWYWx1ZURpZmZlcjxzdHJpbmcsIGFueT47XHJcbiAgLy8gZGlmZmVyIGZvciBtb2RlbERhdGEgb2JqZWN0XHJcbiAgcHJpdmF0ZSBfbWREaWZmZXI6IEtleVZhbHVlRGlmZmVyPHN0cmluZywgYW55PjtcclxuXHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2RpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycywgcHJpdmF0ZSBfa3ZkaWZmZXJzOiBLZXlWYWx1ZURpZmZlcnMsIHB1YmxpYyB6b25lOiBOZ1pvbmUpIHtcclxuICAgIC8vIGRpZmZlcnMgdXNlZCB0byBjaGVjayBpZiB0aGVyZSBoYXZlIGJlZW4gY2hhbmdlZCB0byB0aGUgYXJyYXkgQElucHV0c1xyXG4gICAgLy8gd2l0aG91dCB0aGVtLCBjaGFuZ2VzIHRvIHRoZSBpbnB1dCBhcnJheXMgd29uJ3QgcmVnaXN0ZXIgaW4gbmdPbkNoYW5nZXMsXHJcbiAgICAvLyBzaW5jZSB0aGUgYXJyYXkgcmVmZXJlbmNlIGl0c2VsZiBtYXkgYmUgdGhlIHNhbWVcclxuICAgIHRoaXMuX25kYURpZmZlciA9IHRoaXMuX2t2ZGlmZmVycy5maW5kKFtdKS5jcmVhdGUoKTtcclxuICAgIHRoaXMuX2xkYURpZmZlciA9IHRoaXMuX2t2ZGlmZmVycy5maW5kKFtdKS5jcmVhdGUoKTtcclxuXHJcbiAgICAvLyBhbHNvIHdhdGNoIGlmIG1vZGVsIGRhdGEgY2hhbmdlczsgdGhpcyBkaWZmZXIgbXVzdCBiZSBpbml0aWFsaXplZCBpbiBuZ09uSW5pdFxyXG4gIH1cclxuXHJcbiAgcHVibGljIG5nT25Jbml0KCkge1xyXG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgZGlmZmVyIHRoYXQgbGlzdGVucyBmb3IgY2hhbmdlcyB0byBtb2RlbERhdGEgb2JqZWN0XHJcbiAgICBpZiAodGhpcy5tb2RlbERhdGEpIHtcclxuICAgICAgdGhpcy5fbWREaWZmZXIgPSB0aGlzLl9rdmRpZmZlcnMuZmluZCh0aGlzLm1vZGVsRGF0YSkuY3JlYXRlKCk7XHJcbiAgICB9XHJcbiAgfSAvLyBlbmQgbmdPbkluaXRcclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgZGlhZ3JhbSAvIG1vZGVsIGFmdGVyIHZpZXcgaW5pdFxyXG4gICAqL1xyXG4gIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0gPSB0aGlzLmluaXREaWFncmFtKCk7XHJcblxyXG4gICAgLy8gVGhpcyBiaXQgb2YgY29kZSBtYWtlcyBzdXJlIHRoZSBtb3VzZW1vdmUgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSBjYW52YXMgYXJlIHJ1biBvdXRzaWRlIE5nWm9uZVxyXG4gICAgLy8gVGhpcyBtYWtlcyBpdCBzbyBjaGFuZ2UgZGV0ZWN0aW9uIGlzbid0IHRyaWdnZXJlZCBldmVyeSB0aW1lIHRoZSBtb3VzZSBpcyBtb3ZlZCBpbnNpZGUgdGhlIGNhbnZhcywgZ3JlYXRseSBpbXByb3ZpbmcgcGVyZm9ybWFuY2VcclxuICAgIC8vIElmIHNvbWUgc3RhdGUtYWx0ZXJpbmcgYmVoYXZpb3IgbXVzdCBoYXBwZW4gb24gYSBtb3VzZW1vdmUgZXZlbnQgaW5zaWRlIHRoZSBkaWFncmFtLFxyXG4gICAgLy8geW91IHdpbGwgaGF2ZSB0byB1c2luZyB6b25lLnJ1bigpIHRvIG1ha2Ugc3VyZSB0aGF0IGV2ZW50IHRyaWdnZXJzIGFuZ3VsYXIgY2hhbmdlIGRldGVjdGlvblxyXG4gICAgdGhpcy5kaWFncmFtLmFkZEV2ZW50TGlzdGVuZXIgPSAoRE9NRWxlbWVudDogRWxlbWVudCB8IFdpbmRvdyB8IERvY3VtZW50LCBuYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBhbnksIGNhcHR1cmU6IGJvb2xlYW4pID0+IHtcclxuICAgICAgY29uc3Qgc3VwZXJBZGRFdmVudExpc3RlbmVyID0gZ28uRGlhZ3JhbS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcclxuICAgICAgaWYgKG5hbWUgPT09ICdtb3VzZW1vdmUnKSB7XHJcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHN1cGVyQWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIERPTUVsZW1lbnQsIG5hbWUsIGxpc3RlbmVyLCBjYXB0dXJlKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICBzdXBlckFkZEV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBET01FbGVtZW50LCBuYW1lLCBsaXN0ZW5lciwgY2FwdHVyZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gYXNzaWduIHRoZSBEaWFncmFtJ3MgZGl2LCB3aGljaCAoYW1vbmcgbWFueSBvdGhlciB0aGluZ3MpIHdpbGwgYXR0YWNoIGEgYnVuY2ggb2YgbGlzdGVuZXJzIHRvIHRoZSBjYW52YXMsXHJcbiAgICAvLyB1c2luZyB0aGUgb3ZlcnJpZGRlbiBhZGRFdmVudExpc3RlbmVyIGZ1bmN0aW9uIGFib3ZlXHJcbiAgICBjb25zdCBkaXZSZWYgPSB0aGlzLmRpYWdyYW1EaXYubmF0aXZlRWxlbWVudDtcclxuICAgIGlmIChkaXZSZWYgPT09IG51bGwpIHJldHVybjtcclxuICAgIHRoaXMuZGlhZ3JhbS5kaXYgPSBkaXZSZWY7XHJcblxyXG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgRGlhZ3JhbSdzIG1vZGVsXHJcbiAgICB0aGlzLmRpYWdyYW0uZGVsYXlJbml0aWFsaXphdGlvbigoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5kaWFncmFtLm1vZGVsO1xyXG4gICAgICBtb2RlbC5jb21taXQoKG06IGdvLk1vZGVsKSA9PiB7XHJcbiAgICAgICAgbS5tZXJnZU5vZGVEYXRhQXJyYXkobS5jbG9uZURlZXAodGhpcy5ub2RlRGF0YUFycmF5KSk7XHJcbiAgICAgICAgaWYgKHRoaXMubGlua0RhdGFBcnJheSAmJiBtIGluc3RhbmNlb2YgZ28uR3JhcGhMaW5rc01vZGVsKSB7XHJcbiAgICAgICAgICBtLm1lcmdlTGlua0RhdGFBcnJheShtLmNsb25lRGVlcCh0aGlzLmxpbmtEYXRhQXJyYXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubW9kZWxEYXRhKSB7XHJcbiAgICAgICAgICBtLmFzc2lnbkFsbERhdGFQcm9wZXJ0aWVzKG0ubW9kZWxEYXRhLCB0aGlzLm1vZGVsRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBudWxsKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGluaXRpYWxpemVyIGxpc3RlbmVyXHJcbiAgICB0aGlzLm1vZGVsQ2hhbmdlZExpc3RlbmVyID0gKGU6IGdvLkNoYW5nZWRFdmVudCkgPT4ge1xyXG4gICAgICBpZiAoZS5pc1RyYW5zYWN0aW9uRmluaXNoZWQpIHtcclxuICAgICAgICAvLyB0aGlzIG11c3QgYmUgZG9uZSB3aXRoaW4gYSBOZ1pvbmUucnVuIGJsb2NrLCBzbyBjaGFuZ2VzIGFyZSBkZXRlY3RlZCBpbiB0aGUgcGFyZW50IGNvbXBvbmVudFxyXG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgZGF0YUNoYW5nZXMgPSBlLm1vZGVsIS50b0luY3JlbWVudGFsRGF0YShlKTtcclxuICAgICAgICAgIHRoaXMubW9kZWxDaGFuZ2UuZW1pdChkYXRhQ2hhbmdlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLmRpYWdyYW0uYWRkTW9kZWxDaGFuZ2VkTGlzdGVuZXIodGhpcy5tb2RlbENoYW5nZWRMaXN0ZW5lcik7XHJcblxyXG4gIH0gLy8gZW5kIG5nQWZ0ZXJWaWV3SW5pdFxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEFsd2F5cyBiZSBjaGVja2luZyBpZiBhcnJheSBJbnB1dCBkYXRhIGhhcyBjaGFuZ2VkIChub2RlIGFuZCBsaW5rIGRhdGEgYXJyYXlzKVxyXG4gICAqL1xyXG4gIHB1YmxpYyBuZ0RvQ2hlY2soKSB7XHJcblxyXG5cclxuICAgIFxyXG4gICAgXHJcbiAgICBpZiAoIXRoaXMuZGlhZ3JhbSkgcmV0dXJuO1xyXG4gICAgaWYgKCF0aGlzLmRpYWdyYW0ubW9kZWwpIHJldHVybjtcclxuXHJcbiAgICAvLyB0aGVzZSBuZWVkIHRvIGJlIHJ1biBlYWNoIGNoZWNrLCBldmVuIGlmIG5vIG1lcmdpbmcgaGFwcGVuc1xyXG4gICAgLy8gb3RoZXJ3aXNlLCB0aGV5IHdpbGwgZGV0ZWN0IGFsbCBkaWZmcyB0aGF0IGhhcHBlbmVkIHNpbmNlIGxhc3QgdGltZSBza2lwc0RpYWdyYW0gd2FzIGZhbHNlLFxyXG4gICAgLy8gc3VjaCBhcyByZW1vdmUgb3BzIHRoYXQgaGFwcGVuZWQgaW4gR29KUyB3aGVuIHNraXBzRGlhZ3JhbSA9IHRydWUsIFxyXG4gICAgLy8gYW5kIHRoZW4gcmVhbGxsbGxseSBiYWQgc3R1ZmYgaGFwcGVucyAoZGVsZXRpbmcgcmFuZG9tIG5vZGVzLCB1cGRhdGluZyB0aGUgd3JvbmcgUGFydHMpXHJcbiAgICAvLyBBbmd1bGFyIGRpZmZlcnMgYXJlIGEgbG90IG9mIGZ1blxyXG4gICAgdmFyIG5vZGVEaWZmcyA9IHRoaXMuX25kYURpZmZlci5kaWZmKHRoaXMubm9kZURhdGFBcnJheSk7XHJcbiAgICB2YXIgbGlua0RpZmZzID0gdGhpcy5fbGRhRGlmZmVyLmRpZmYodGhpcy5saW5rRGF0YUFycmF5KTtcclxuXHJcbiAgICBpZiAodGhpcy5za2lwc0RpYWdyYW1VcGRhdGUpIHJldHVybjtcclxuXHJcbiAgICBmdW5jdGlvbiBjb21wYXJlT2JqcyhvYmoxLCBvYmoyKSB7XHJcbiAgICAgIC8vIExvb3AgdGhyb3VnaCBwcm9wZXJ0aWVzIGluIG9iamVjdCAxXHJcbiAgICAgIGZvciAoY29uc3QgcCBpbiBvYmoxKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgcHJvcGVydHkgZXhpc3RzIG9uIGJvdGggb2JqZWN0c1xyXG4gICAgICAgIGlmIChvYmoxLmhhc093blByb3BlcnR5KHApICE9PSBvYmoyLmhhc093blByb3BlcnR5KHApKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIChvYmoxW3BdKSkge1xyXG4gICAgICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHNcclxuICAgICAgICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgICAgICAgIGlmICghY29tcGFyZU9ianMob2JqMVtwXSwgb2JqMltwXSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAvLyBDb21wYXJlIHZhbHVlc1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKG9iajFbcF0gIT09IG9iajJbcF0pIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIG9iamVjdCAyIGZvciBhbnkgZXh0cmEgcHJvcGVydGllc1xyXG4gICAgICBmb3IgKGNvbnN0IHAgaW4gb2JqMikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKG9iajFbcF0pID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkYyA9IHRoaXM7XHJcbiAgICAvLyBtZXJnZXMgY2hhbmdlcyBmcm9tIGFwcCBkYXRhIGludG8gR29KUyBtb2RlbCBkYXRhLCBcclxuICAgIC8vIG1ha2luZyBzdXJlIG9ubHkgYWN0dWFsIGNoYW5nZXMgKGFuZCBub3QgZmFsc2VseSBmbGFnZ2VkIG5vLW9wcyBvbiBhcnJheSAvIG9iaiBkYXRhIHByb3BzKSBhcmUgbG9nZ2VkXHJcbiAgICBmdW5jdGlvbiBtZXJnZUNoYW5nZXMoa3ZjaGFuZ2VzLCBzdHIpOiBib29sZWFuIHtcclxuICAgICAgaWYgKCFkYy5kaWFncmFtIHx8ICFkYy5kaWFncmFtLm1vZGVsKSByZXR1cm47XHJcblxyXG4gICAgICBpZiAoa3ZjaGFuZ2VzKSB7XHJcbiAgICAgICAga3ZjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oKHI6IEtleVZhbHVlQ2hhbmdlUmVjb3JkPHN0cmluZywgYW55PikgPT4ge1xyXG4gICAgICAgICAgc3dpdGNoIChzdHIpIHtcclxuICAgICAgICAgICAgY2FzZSBcIm5cIjoge1xyXG4gICAgICAgICAgICAgIGRjLmRpYWdyYW0ubW9kZWwuYWRkTm9kZURhdGEoci5jdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJsXCI6IHtcclxuICAgICAgICAgICAgICB2YXIgbSA9IDxnby5HcmFwaExpbmtzTW9kZWw+ZGMuZGlhZ3JhbS5tb2RlbDtcclxuICAgICAgICAgICAgICBtLmFkZExpbmtEYXRhKHIuY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGt2Y2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oKHI6IEtleVZhbHVlQ2hhbmdlUmVjb3JkPHN0cmluZywgYW55PikgPT4ge1xyXG4gICAgICAgICAgc3dpdGNoIChzdHIpIHtcclxuICAgICAgICAgICAgY2FzZSBcIm5cIjoge1xyXG4gICAgICAgICAgICAgIHZhciBub2RlID0gZGMuZGlhZ3JhbS5maW5kTm9kZXNCeUV4YW1wbGUoci5wcmV2aW91c1ZhbHVlKS5maXJzdCgpO1xyXG4gICAgICAgICAgICAgIGRjLmRpYWdyYW0ucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJsXCI6IHtcclxuICAgICAgICAgICAgICB2YXIgbGluayA9IGRjLmRpYWdyYW0uZmluZExpbmtzQnlFeGFtcGxlKHIucHJldmlvdXNWYWx1ZSkuZmlyc3QoKTtcclxuICAgICAgICAgICAgICBkYy5kaWFncmFtLnJlbW92ZShsaW5rKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBrdmNoYW5nZXMuZm9yRWFjaENoYW5nZWRJdGVtKChyOiBLZXlWYWx1ZUNoYW5nZVJlY29yZDxzdHJpbmcsIGFueT4pID0+IHtcclxuICAgICAgICAgIGNvbnN0IGN1clZhbCA9IHIuY3VycmVudFZhbHVlO1xyXG4gICAgICAgICAgY29uc3QgcFZhbCA9IHIucHJldmlvdXNWYWx1ZTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gZW5zdXJlIFwiY2hhbmdlc1wiIHRvIGFycmF5IC8gb2JqZWN0IC8gZW51bWVyYWJsZSBkYXRhIHByb3BlcnRpZXMgYXJlIGxlZ2l0XHJcbiAgICAgICAgICBjb25zdCBzYW1lVmFscyA9IGNvbXBhcmVPYmpzKGN1clZhbCwgcFZhbCk7XHJcbiAgICAgICAgICBpZiAoIXNhbWVWYWxzKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoc3RyKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSBcIm5cIjoge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBkYy5kaWFncmFtLmZpbmROb2Rlc0J5RXhhbXBsZShyLnByZXZpb3VzVmFsdWUpLmZpcnN0KCk7XHJcbiAgICAgICAgICAgICAgICBkYy5kaWFncmFtLm1vZGVsLmFzc2lnbkFsbERhdGFQcm9wZXJ0aWVzKG5vZGUuZGF0YSwgci5jdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNhc2UgXCJsXCI6IHtcclxuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gZGMuZGlhZ3JhbS5maW5kTGlua3NCeUV4YW1wbGUoci5wcmV2aW91c1ZhbHVlKS5maXJzdCgpO1xyXG4gICAgICAgICAgICAgICAgZGMuZGlhZ3JhbS5tb2RlbC5hc3NpZ25BbGxEYXRhUHJvcGVydGllcyhsaW5rLmRhdGEsIHIuY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgLy8gZG9uJ3QgbmVlZCBtb2RlbCBjaGFuZ2UgbGlzdGVuZXIgd2hpbGUgcGVyZm9ybWluZyBrbm93biBkYXRhIHVwZGF0ZXNcclxuICAgIGlmICh0aGlzLm1vZGVsQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB0aGlzLmRpYWdyYW0ubW9kZWwucmVtb3ZlQ2hhbmdlZExpc3RlbmVyKHRoaXMubW9kZWxDaGFuZ2VkTGlzdGVuZXIpO1xyXG5cclxuICAgIHRoaXMuZGlhZ3JhbS5tb2RlbC5zdGFydFRyYW5zYWN0aW9uKCd1cGRhdGUgZGF0YScpO1xyXG4gICAgLy8gdmFyIG5vZGVEaWZmcyA9IHRoaXMuX25kYURpZmZlci5kaWZmKHRoaXMubm9kZURhdGFBcnJheSk7XHJcbiAgICBtZXJnZUNoYW5nZXMobm9kZURpZmZzLCBcIm5cIik7XHJcbiAgICBtZXJnZUNoYW5nZXMobGlua0RpZmZzLCBcImxcIik7XHJcbiAgICB0aGlzLmRpYWdyYW0ubW9kZWwuYXNzaWduQWxsRGF0YVByb3BlcnRpZXModGhpcy5kaWFncmFtLm1vZGVsLm1vZGVsRGF0YSwgdGhpcy5tb2RlbERhdGEpO1xyXG4gICAgdGhpcy5kaWFncmFtLm1vZGVsLmNvbW1pdFRyYW5zYWN0aW9uKCd1cGRhdGUgZGF0YScpO1xyXG4gICAgLy8gcmVzZXQgdGhlIG1vZGVsIGNoYW5nZSBsaXN0ZW5lclxyXG4gICAgaWYgKHRoaXMubW9kZWxDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHRoaXMuZGlhZ3JhbS5tb2RlbC5hZGRDaGFuZ2VkTGlzdGVuZXIodGhpcy5tb2RlbENoYW5nZWRMaXN0ZW5lcik7XHJcblxyXG4gIH0gLy8gZW5kIG5nRG9DaGVja1xyXG5cclxuICAvKipcclxuICAgKiBTb21lIGlucHV0IHByb3BlcnR5IGhhcyBjaGFuZ2VkIChvciBpdHMgY29udGVudHMgY2hhbmdlZCkgaW4gcGFyZW50IGNvbXBvbmVudC5cclxuICAgKiBVcGRhdGUgZGlhZ3JhbSBkYXRhIGFjY29yZGluZ2x5XHJcbiAgICovXHJcbiAgLy8gcHVibGljIHVwZGF0ZUZyb21BcHBEYXRhKCkge1xyXG4gIC8vICAgaWYgKCF0aGlzLmRpYWdyYW0pIHJldHVybjtcclxuICAvLyAgIGNvbnN0IG1vZGVsID0gdGhpcy5kaWFncmFtLm1vZGVsO1xyXG5cclxuICAvLyAgIC8vIGRvbid0IG5lZWQgbW9kZWwgY2hhbmdlIGxpc3RlbmVyIHdoaWxlIHBlcmZvcm1pbmcga25vd24gZGF0YSB1cGRhdGVzXHJcbiAgLy8gICBpZiAodGhpcy5tb2RlbENoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkgbW9kZWwucmVtb3ZlQ2hhbmdlZExpc3RlbmVyKHRoaXMubW9kZWxDaGFuZ2VkTGlzdGVuZXIpO1xyXG5cclxuICAvLyAgIG1vZGVsLnN0YXJ0VHJhbnNhY3Rpb24oJ3VwZGF0ZSBkYXRhJyk7XHJcbiAgLy8gICBtb2RlbC5tZXJnZU5vZGVEYXRhQXJyYXkobW9kZWwuY2xvbmVEZWVwKHRoaXMubm9kZURhdGFBcnJheSkpO1xyXG4gIC8vICAgaWYgKHRoaXMubGlua0RhdGFBcnJheSAmJiBtb2RlbCBpbnN0YW5jZW9mIGdvLkdyYXBoTGlua3NNb2RlbCkge1xyXG4gIC8vICAgICBtb2RlbC5tZXJnZUxpbmtEYXRhQXJyYXkobW9kZWwuY2xvbmVEZWVwKHRoaXMubGlua0RhdGFBcnJheSkpO1xyXG4gIC8vICAgfVxyXG4gIC8vICAgaWYgKHRoaXMubW9kZWxEYXRhKSB7XHJcbiAgLy8gICAgIG1vZGVsLmFzc2lnbkFsbERhdGFQcm9wZXJ0aWVzKG1vZGVsLm1vZGVsRGF0YSwgdGhpcy5tb2RlbERhdGEpO1xyXG4gIC8vICAgfVxyXG4gIC8vICAgbW9kZWwuY29tbWl0VHJhbnNhY3Rpb24oJ3VwZGF0ZSBkYXRhJyk7XHJcblxyXG4gIC8vICAgLy8gcmVzZXQgdGhlIG1vZGVsIGNoYW5nZSBsaXN0ZW5lclxyXG4gIC8vICAgaWYgKHRoaXMubW9kZWxDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIG1vZGVsLmFkZENoYW5nZWRMaXN0ZW5lcih0aGlzLm1vZGVsQ2hhbmdlZExpc3RlbmVyKTtcclxuXHJcbiAgLy8gfVxyXG5cclxufVxyXG4iXX0=