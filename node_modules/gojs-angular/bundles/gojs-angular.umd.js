(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('gojs')) :
    typeof define === 'function' && define.amd ? define('gojs-angular', ['exports', '@angular/core', 'gojs'], factory) :
    (global = global || self, factory(global['gojs-angular'] = {}, global.ng.core, global.go));
}(this, (function (exports, i0, go) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/diagram.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DiagramComponent = /** @class */ (function () {
        /**
         * @param {?} _differs
         * @param {?} _kvdiffers
         * @param {?} zone
         */
        function DiagramComponent(_differs, _kvdiffers, zone) {
            this._differs = _differs;
            this._kvdiffers = _kvdiffers;
            this.zone = zone;
            // Link data for diagram
            this.linkDataArray = null; // optional
            // optional
            // Model data for diagram
            this.modelData = null; // optional
            // model changed listener function for diagram
            this.modelChangedListener = null;
            this.skipsDiagramUpdate = false;
            // event emitter -- fires when diagram model changes. Capture this emitted event in parent component
            this.modelChange = new i0.EventEmitter();
            this.diagram = null;
            // differs used to check if there have been changed to the array @Inputs
            // without them, changes to the input arrays won't register in ngOnChanges,
            // since the array reference itself may be the same
            this._ndaDiffer = this._kvdiffers.find([]).create();
            this._ldaDiffer = this._kvdiffers.find([]).create();
            // also watch if model data changes; this differ must be initialized in ngOnInit
        }
        /**
         * @return {?}
         */
        DiagramComponent.prototype.ngOnInit = function () {
            // initialize the differ that listens for changes to modelData object
            if (this.modelData) {
                this._mdDiffer = this._kvdiffers.find(this.modelData).create();
            }
        }; // end ngOnInit
        // end ngOnInit
        /**
         * Initializes diagram / model after view init
         * @return {?}
         */
        DiagramComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.diagram = this.initDiagram();
            // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
            // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
            // If some state-altering behavior must happen on a mousemove event inside the diagram,
            // you will have to using zone.run() to make sure that event triggers angular change detection
            this.diagram.addEventListener = ( /**
             * @param {?} DOMElement
             * @param {?} name
             * @param {?} listener
             * @param {?} capture
             * @return {?}
             */function (DOMElement, name, listener, capture) {
                /** @type {?} */
                var superAddEventListener = go.Diagram.prototype.addEventListener;
                if (name === 'mousemove') {
                    _this.zone.runOutsideAngular(( /**
                     * @return {?}
                     */function () { return superAddEventListener.call(_this, DOMElement, name, listener, capture); }));
                }
                else {
                    _this.zone.run(( /**
                     * @return {?}
                     */function () {
                        superAddEventListener.call(_this, DOMElement, name, listener, capture);
                    }));
                }
            });
            // assign the Diagram's div, which (among many other things) will attach a bunch of listeners to the canvas,
            // using the overridden addEventListener function above
            /** @type {?} */
            var divRef = this.diagramDiv.nativeElement;
            if (divRef === null)
                return;
            this.diagram.div = divRef;
            // initialize the Diagram's model
            this.diagram.delayInitialization(( /**
             * @return {?}
             */function () {
                /** @type {?} */
                var model = _this.diagram.model;
                model.commit(( /**
                 * @param {?} m
                 * @return {?}
                 */function (m) {
                    m.mergeNodeDataArray(m.cloneDeep(_this.nodeDataArray));
                    if (_this.linkDataArray && m instanceof go.GraphLinksModel) {
                        m.mergeLinkDataArray(m.cloneDeep(_this.linkDataArray));
                    }
                    if (_this.modelData) {
                        m.assignAllDataProperties(m.modelData, _this.modelData);
                    }
                }), null);
            }));
            // initializer listener
            this.modelChangedListener = ( /**
             * @param {?} e
             * @return {?}
             */function (e) {
                if (e.isTransactionFinished) {
                    // this must be done within a NgZone.run block, so changes are detected in the parent component
                    _this.zone.run(( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var dataChanges = ( /** @type {?} */(e.model)).toIncrementalData(e);
                        _this.modelChange.emit(dataChanges);
                    }));
                }
            });
            this.diagram.addModelChangedListener(this.modelChangedListener);
        }; // end ngAfterViewInit
        // end ngAfterViewInit
        /**
         * Always be checking if array Input data has changed (node and link data arrays)
         * @return {?}
         */
        DiagramComponent.prototype.ngDoCheck = function () {
            if (!this.diagram)
                return;
            if (!this.diagram.model)
                return;
            // these need to be run each check, even if no merging happens
            // otherwise, they will detect all diffs that happened since last time skipsDiagram was false,
            // such as remove ops that happened in GoJS when skipsDiagram = true, 
            // and then realllllly bad stuff happens (deleting random nodes, updating the wrong Parts)
            // Angular differs are a lot of fun
            /** @type {?} */
            var nodeDiffs = this._ndaDiffer.diff(this.nodeDataArray);
            /** @type {?} */
            var linkDiffs = this._ldaDiffer.diff(this.linkDataArray);
            if (this.skipsDiagramUpdate)
                return;
            /**
             * @param {?} obj1
             * @param {?} obj2
             * @return {?}
             */
            function compareObjs(obj1, obj2) {
                // Loop through properties in object 1
                for (var p in obj1) {
                    // Check property exists on both objects
                    if (obj1.hasOwnProperty(p) !== obj2.hasOwnProperty(p))
                        return false;
                    switch (typeof (obj1[p])) {
                        // Deep compare objects
                        case 'object':
                            if (!compareObjs(obj1[p], obj2[p]))
                                return false;
                            break;
                        // Compare values
                        default:
                            if (obj1[p] !== obj2[p])
                                return false;
                    }
                }
                // Check object 2 for any extra properties
                for (var p in obj2) {
                    if (typeof (obj1[p]) === 'undefined')
                        return false;
                }
                return true;
            }
            /** @type {?} */
            var dc = this;
            // merges changes from app data into GoJS model data, 
            // making sure only actual changes (and not falsely flagged no-ops on array / obj data props) are logged
            /**
             * @param {?} kvchanges
             * @param {?} str
             * @return {?}
             */
            function mergeChanges(kvchanges, str) {
                if (!dc.diagram || !dc.diagram.model)
                    return;
                if (kvchanges) {
                    kvchanges.forEachAddedItem(( /**
                     * @param {?} r
                     * @return {?}
                     */function (r) {
                        switch (str) {
                            case "n": {
                                dc.diagram.model.addNodeData(r.currentValue);
                                break;
                            }
                            case "l": {
                                /** @type {?} */
                                var m = ( /** @type {?} */(dc.diagram.model));
                                m.addLinkData(r.currentValue);
                                break;
                            }
                        }
                    }));
                    kvchanges.forEachRemovedItem(( /**
                     * @param {?} r
                     * @return {?}
                     */function (r) {
                        switch (str) {
                            case "n": {
                                /** @type {?} */
                                var node = dc.diagram.findNodesByExample(r.previousValue).first();
                                dc.diagram.remove(node);
                                break;
                            }
                            case "l": {
                                /** @type {?} */
                                var link = dc.diagram.findLinksByExample(r.previousValue).first();
                                dc.diagram.remove(link);
                                break;
                            }
                        }
                    }));
                    kvchanges.forEachChangedItem(( /**
                     * @param {?} r
                     * @return {?}
                     */function (r) {
                        /** @type {?} */
                        var curVal = r.currentValue;
                        /** @type {?} */
                        var pVal = r.previousValue;
                        // ensure "changes" to array / object / enumerable data properties are legit
                        /** @type {?} */
                        var sameVals = compareObjs(curVal, pVal);
                        if (!sameVals) {
                            switch (str) {
                                case "n": {
                                    /** @type {?} */
                                    var node = dc.diagram.findNodesByExample(r.previousValue).first();
                                    dc.diagram.model.assignAllDataProperties(node.data, r.currentValue);
                                    break;
                                }
                                case "l": {
                                    /** @type {?} */
                                    var link = dc.diagram.findLinksByExample(r.previousValue).first();
                                    dc.diagram.model.assignAllDataProperties(link.data, r.currentValue);
                                    break;
                                }
                            }
                        }
                    }));
                }
            }
            // don't need model change listener while performing known data updates
            if (this.modelChangedListener !== null)
                this.diagram.model.removeChangedListener(this.modelChangedListener);
            this.diagram.model.startTransaction('update data');
            // var nodeDiffs = this._ndaDiffer.diff(this.nodeDataArray);
            mergeChanges(nodeDiffs, "n");
            mergeChanges(linkDiffs, "l");
            this.diagram.model.assignAllDataProperties(this.diagram.model.modelData, this.modelData);
            this.diagram.model.commitTransaction('update data');
            // reset the model change listener
            if (this.modelChangedListener !== null)
                this.diagram.model.addChangedListener(this.modelChangedListener);
        }; // end ngDoCheck
        return DiagramComponent;
    }());
    DiagramComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'gojs-diagram',
                    template: '<div #ngDiagram [className]=divClassName></div>'
                }] }
    ];
    /** @nocollapse */
    DiagramComponent.ctorParameters = function () { return [
        { type: i0.IterableDiffers },
        { type: i0.KeyValueDiffers },
        { type: i0.NgZone }
    ]; };
    DiagramComponent.propDecorators = {
        initDiagram: [{ type: i0.Input }],
        nodeDataArray: [{ type: i0.Input }],
        linkDataArray: [{ type: i0.Input }],
        modelData: [{ type: i0.Input }],
        divClassName: [{ type: i0.Input }],
        modelChangedListener: [{ type: i0.Input }],
        skipsDiagramUpdate: [{ type: i0.Input }],
        modelChange: [{ type: i0.Output }],
        diagramDiv: [{ type: i0.ViewChild, args: ['ngDiagram', { static: true },] }]
    };
    if (false) {
        /**
         * Diagram initialization function. Returns a go.Diagram.
         * Do not initialize model data in this function.
         * @type {?}
         */
        DiagramComponent.prototype.initDiagram;
        /** @type {?} */
        DiagramComponent.prototype.nodeDataArray;
        /** @type {?} */
        DiagramComponent.prototype.linkDataArray;
        /** @type {?} */
        DiagramComponent.prototype.modelData;
        /** @type {?} */
        DiagramComponent.prototype.divClassName;
        /** @type {?} */
        DiagramComponent.prototype.modelChangedListener;
        /** @type {?} */
        DiagramComponent.prototype.skipsDiagramUpdate;
        /** @type {?} */
        DiagramComponent.prototype.modelChange;
        /** @type {?} */
        DiagramComponent.prototype.diagramDiv;
        /** @type {?} */
        DiagramComponent.prototype.diagram;
        /**
         * @type {?}
         * @private
         */
        DiagramComponent.prototype._ndaDiffer;
        /**
         * @type {?}
         * @private
         */
        DiagramComponent.prototype._ldaDiffer;
        /**
         * @type {?}
         * @private
         */
        DiagramComponent.prototype._mdDiffer;
        /**
         * @type {?}
         * @private
         */
        DiagramComponent.prototype._differs;
        /**
         * @type {?}
         * @private
         */
        DiagramComponent.prototype._kvdiffers;
        /** @type {?} */
        DiagramComponent.prototype.zone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/palette.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PaletteComponent = /** @class */ (function () {
        /**
         * @param {?} _differs
         * @param {?} _kvdiffers
         * @param {?} zone
         */
        function PaletteComponent(_differs, _kvdiffers, zone) {
            this._differs = _differs;
            this._kvdiffers = _kvdiffers;
            this.zone = zone;
            // Link data for palette. Optional
            this.linkDataArray = null;
            // Model data for palette. Optional
            this.modelData = null;
            // model changed listener function for palette
            this.modelChangedListener = null;
            // event emitter -- fires when palette model changes. Capture this emitted event in parent component
            this.modelChange = new i0.EventEmitter();
            // The Palette itself
            this.palette = null;
            // differs used to check if there have been changed to the array @Inputs
            // without them, changes to the input arrays won't register in ngOnChanges,
            // since the array reference itself may be the same
            this._ndaDiffer = this._differs.find([]).create(null);
            this._ldaDiffer = this._differs.find([]).create(null);
            // also watch if model data changes; this differ must be initialized in ngOnInit
        } // end constructor
        // end constructor
        /**
         * @return {?}
         */
        PaletteComponent.prototype.ngOnInit = function () {
            // initialize the differ that listens for changes to modelData object
            if (this.modelData) {
                this._mdDiffer = this._kvdiffers.find(this.modelData).create();
            }
        }; // end ngOnInit
        // end ngOnInit
        /**
         * Initialize Palette after view init
         * @return {?}
         */
        PaletteComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (!this.paletteDiv)
                return;
            this.palette = this.initPalette();
            // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
            // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
            // If some state-altering behavior must happen on a mousemove event inside the palette,
            // you will have to using zone.run() to make sure that event triggers angular change detection
            this.palette.addEventListener = ( /**
             * @param {?} DOMElement
             * @param {?} name
             * @param {?} listener
             * @param {?} capture
             * @return {?}
             */function (DOMElement, name, listener, capture) {
                /** @type {?} */
                var superAddEventListener = go.Diagram.prototype.addEventListener;
                if (name === 'mousemove') {
                    _this.zone.runOutsideAngular(( /**
                     * @return {?}
                     */function () { return superAddEventListener.call(_this, DOMElement, name, listener, capture); }));
                }
                else {
                    _this.zone.run(( /**
                     * @return {?}
                     */function () {
                        superAddEventListener.call(_this, DOMElement, name, listener, capture);
                    }));
                }
            });
            // assign the Palette's div, which (among many other things) will attach a bunch of listeners to the canvas,
            // using the overridden addEventListener function above
            /** @type {?} */
            var divRef = this.paletteDiv.nativeElement;
            this.palette.div = divRef;
            // initialize palette model
            this.palette.delayInitialization(( /**
             * @return {?}
             */function () {
                /** @type {?} */
                var model = _this.palette.model;
                model.commit(( /**
                 * @param {?} m
                 * @return {?}
                 */function (m) {
                    m.mergeNodeDataArray(m.cloneDeep(_this.nodeDataArray));
                    if (_this.linkDataArray && m instanceof go.GraphLinksModel) {
                        m.mergeLinkDataArray(m.cloneDeep(_this.linkDataArray));
                    }
                    if (_this.modelData) {
                        m.assignAllDataProperties(m.modelData, _this.modelData);
                    }
                }), null);
            }));
            // initializer listener
            this.modelChangedListener = ( /**
             * @param {?} e
             * @return {?}
             */function (e) {
                if (e.isTransactionFinished) {
                    // this must be done within a NgZone.run block, so changes are detected in the parent component
                    _this.zone.run(( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var dataChanges = ( /** @type {?} */(e.model)).toIncrementalData(e);
                        _this.modelChange.emit(dataChanges);
                    }));
                }
            });
            this.palette.addModelChangedListener(this.modelChangedListener);
        }; // end ngAfterViewInit
        // end ngAfterViewInit
        /**
         * Always be checking if array Input data has changed (node and link data arrays)
         * @return {?}
         */
        PaletteComponent.prototype.ngDoCheck = function () {
            /** @type {?} */
            var nodeDataArrayChanges = this._ndaDiffer.diff(this.nodeDataArray);
            /** @type {?} */
            var linkDataArrayChanges = this._ldaDiffer.diff(this.linkDataArray);
            /** @type {?} */
            var modelDataChanges = null;
            if (this._mdDiffer) {
                modelDataChanges = this._mdDiffer.diff(this.modelData);
            }
            if (nodeDataArrayChanges || linkDataArrayChanges || modelDataChanges) {
                this.updateFromAppData();
            }
        }; // end ngDoCheck
        // end ngDoCheck
        /**
         * Some input property has changed (or its contents changed) in parent component.
         * Update palette data accordingly
         * @return {?}
         */
        PaletteComponent.prototype.updateFromAppData = function () {
            if (!this.palette)
                return;
            /** @type {?} */
            var model = this.palette.model;
            model.startTransaction('update data');
            model.mergeNodeDataArray(model.cloneDeep(this.nodeDataArray));
            if (this.linkDataArray && model instanceof go.GraphLinksModel) {
                model.mergeLinkDataArray(model.cloneDeep(this.linkDataArray));
            }
            if (this.modelData) {
                model.assignAllDataProperties(model.modelData, this.modelData);
            }
            model.commitTransaction('update data');
        };
        return PaletteComponent;
    }());
    PaletteComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'gojs-palette',
                    template: '<div #ngPalette [className]=divClassName></div>'
                }] }
    ];
    /** @nocollapse */
    PaletteComponent.ctorParameters = function () { return [
        { type: i0.IterableDiffers },
        { type: i0.KeyValueDiffers },
        { type: i0.NgZone }
    ]; };
    PaletteComponent.propDecorators = {
        initPalette: [{ type: i0.Input }],
        nodeDataArray: [{ type: i0.Input }],
        linkDataArray: [{ type: i0.Input }],
        modelData: [{ type: i0.Input }],
        divClassName: [{ type: i0.Input }],
        modelChangedListener: [{ type: i0.Input }],
        modelChange: [{ type: i0.Output }],
        paletteDiv: [{ type: i0.ViewChild, args: ['ngPalette', { static: true },] }]
    };
    if (false) {
        /**
         * Palette initialization function. Returns a go.Palette.
         * Do not initialize model data in this function.
         * @type {?}
         */
        PaletteComponent.prototype.initPalette;
        /** @type {?} */
        PaletteComponent.prototype.nodeDataArray;
        /** @type {?} */
        PaletteComponent.prototype.linkDataArray;
        /** @type {?} */
        PaletteComponent.prototype.modelData;
        /** @type {?} */
        PaletteComponent.prototype.divClassName;
        /** @type {?} */
        PaletteComponent.prototype.modelChangedListener;
        /** @type {?} */
        PaletteComponent.prototype.modelChange;
        /** @type {?} */
        PaletteComponent.prototype.paletteDiv;
        /** @type {?} */
        PaletteComponent.prototype.palette;
        /** @type {?} */
        PaletteComponent.prototype._ndaDiffer;
        /** @type {?} */
        PaletteComponent.prototype._ldaDiffer;
        /**
         * @type {?}
         * @private
         */
        PaletteComponent.prototype._mdDiffer;
        /**
         * @type {?}
         * @private
         */
        PaletteComponent.prototype._differs;
        /**
         * @type {?}
         * @private
         */
        PaletteComponent.prototype._kvdiffers;
        /** @type {?} */
        PaletteComponent.prototype.zone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/overview.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OverviewComponent = /** @class */ (function () {
        /**
         * @param {?} zone
         */
        function OverviewComponent(zone) {
            this.zone = zone;
            // The Diagram to observe with the Overview
            this.observedDiagram = null;
            // The Overview itself
            this.overview = null;
        }
        /**
         * Initialize the overview
         * @return {?}
         */
        OverviewComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (!this.overviewDiv)
                return;
            if (this.initOverview) {
                this.overview = this.initOverview();
            }
            else {
                this.overview = new go.Overview();
                this.overview.contentAlignment = go.Spot.Center;
            }
            // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
            // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
            // If some state-altering behavior must happen on a mousemove event inside the overview,
            // you will have to using zone.run() to make sure that event triggers angular change detection
            this.overview.addEventListener = ( /**
             * @param {?} DOMElement
             * @param {?} name
             * @param {?} listener
             * @param {?} capture
             * @return {?}
             */function (DOMElement, name, listener, capture) {
                /** @type {?} */
                var superAddEventListener = go.Diagram.prototype.addEventListener;
                if (name === 'mousemove') {
                    _this.zone.runOutsideAngular(( /**
                     * @return {?}
                     */function () { return superAddEventListener.call(_this, DOMElement, name, listener, capture); }));
                }
                else {
                    _this.zone.run(( /**
                     * @return {?}
                     */function () {
                        superAddEventListener.call(_this, DOMElement, name, listener, capture);
                    }));
                }
            });
            this.overview.div = this.overviewDiv.nativeElement;
        };
        /**
         * Only update when the observed diagram changes
         * @param {?} changes
         * @return {?}
         */
        OverviewComponent.prototype.ngOnChanges = function (changes) {
            if (!this.overview)
                return;
            if (changes && changes.observedDiagram && changes.observedDiagram.currentValue !== changes.observedDiagram.previousValue) {
                this.overview.observed = changes.observedDiagram.currentValue;
            }
        };
        return OverviewComponent;
    }());
    OverviewComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'gojs-overview',
                    template: '<div #ngOverview [className]=divClassName></div>'
                }] }
    ];
    /** @nocollapse */
    OverviewComponent.ctorParameters = function () { return [
        { type: i0.NgZone }
    ]; };
    OverviewComponent.propDecorators = {
        initOverview: [{ type: i0.Input }],
        divClassName: [{ type: i0.Input }],
        observedDiagram: [{ type: i0.Input }],
        overviewDiv: [{ type: i0.ViewChild, args: ['ngOverview', { static: true },] }]
    };
    if (false) {
        /** @type {?} */
        OverviewComponent.prototype.initOverview;
        /** @type {?} */
        OverviewComponent.prototype.divClassName;
        /** @type {?} */
        OverviewComponent.prototype.observedDiagram;
        /** @type {?} */
        OverviewComponent.prototype.overviewDiv;
        /** @type {?} */
        OverviewComponent.prototype.overview;
        /** @type {?} */
        OverviewComponent.prototype.zone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/gojs-angular.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var GojsAngularModule = /** @class */ (function () {
        function GojsAngularModule() {
        }
        return GojsAngularModule;
    }());
    GojsAngularModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        DiagramComponent,
                        OverviewComponent,
                        PaletteComponent
                    ],
                    imports: [],
                    exports: [
                        DiagramComponent,
                        OverviewComponent,
                        PaletteComponent
                    ]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/data-sync.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DataSyncService = /** @class */ (function () {
        function DataSyncService() {
        }
        /**
         * Sync a node data array with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} nodeData The node data array to merge these changes with
         * @return {?} A node data array, merged with the changes
         */
        DataSyncService.syncNodeData = function (changes, nodeData) {
            if (!changes)
                return nodeData;
            if (!changes.modifiedNodeData && !changes.insertedNodeKeys && !changes.removedNodeKeys)
                return nodeData;
            // maintain a map of modified nodes for fast lookup during insertion
            /** @type {?} */
            var modifiedNodesMap = new go.Map();
            // account for modified node data
            if (changes.modifiedNodeData) {
                changes.modifiedNodeData.forEach(( /**
                 * @param {?} nd
                 * @return {?}
                 */function (nd) {
                    modifiedNodesMap.set(nd.key, nd);
                    /** @type {?} */
                    var key = nd.key;
                    for (var i = 0; i < nodeData.length; i++) {
                        /** @type {?} */
                        var ndEntry = nodeData[i];
                        if (ndEntry.key === key) {
                            nodeData[i] = nd;
                        }
                    }
                }));
            }
            // account for inserted node data
            if (changes.insertedNodeKeys) {
                changes.insertedNodeKeys.forEach(( /**
                 * @param {?} key
                 * @return {?}
                 */function (key) {
                    /** @type {?} */
                    var nd = modifiedNodesMap.get(key);
                    if (nd) {
                        nodeData.push(nd);
                    }
                }));
            }
            // account for removed node data
            if (changes.removedNodeKeys) {
                nodeData = nodeData.filter(( /**
                 * @param {?} nd
                 * @return {?}
                 */function (nd) {
                    if (changes.removedNodeKeys.includes(nd.key)) {
                        return false;
                    }
                    return true;
                }));
            }
            return nodeData;
        };
        /**
         * Sync a link data array with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} linkData The link data array to merge these changes with
         * @return {?} A link data array, merged with the changes
         */
        DataSyncService.syncLinkData = function (changes, linkData) {
            if (!changes)
                return linkData;
            if (!changes.modifiedLinkData && !changes.insertedLinkKeys && !changes.removedLinkKeys)
                return linkData;
            // maintain a map of modified nodes for fast lookup during insertion
            /** @type {?} */
            var modifiedLinksMap = new go.Map();
            // account for modified link data
            if (changes.modifiedLinkData) {
                changes.modifiedLinkData.forEach(( /**
                 * @param {?} ld
                 * @return {?}
                 */function (ld) {
                    modifiedLinksMap.set(ld.key, ld);
                    /** @type {?} */
                    var key = ld.key;
                    for (var i = 0; i < linkData.length; i++) {
                        /** @type {?} */
                        var ldEntry = linkData[i];
                        if (ldEntry.key === key) {
                            linkData[i] = ld;
                        }
                    }
                }));
            }
            // account for inserted link data
            if (changes.insertedLinkKeys) {
                changes.insertedLinkKeys.forEach(( /**
                 * @param {?} key
                 * @return {?}
                 */function (key) {
                    /** @type {?} */
                    var nd = modifiedLinksMap.get(key);
                    if (nd) {
                        linkData.push(nd);
                    }
                }));
            }
            // account for removed link data
            if (changes.removedLinkKeys) {
                linkData = linkData.filter(( /**
                 * @param {?} ld
                 * @return {?}
                 */function (ld) {
                    if (changes.removedLinkKeys.includes(ld.key)) {
                        return false;
                    }
                    return true;
                }));
            }
            return linkData;
        };
        /**
         * Sync modelData with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} modelData The modelData to merge these changes with
         * @return {?} A modelData object, merged with the changes
         */
        DataSyncService.syncModelData = function (changes, modelData) {
            if (!changes)
                return modelData;
            if (!changes.modelData)
                return modelData;
            if (changes.modelData) {
                return changes.modelData;
            }
        };
        return DataSyncService;
    }());
    DataSyncService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    DataSyncService.ctorParameters = function () { return []; };
    /** @nocollapse */ DataSyncService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DataSyncService_Factory() { return new DataSyncService(); }, token: DataSyncService, providedIn: "root" });

    /**
     * @fileoverview added by tsickle
     * Generated from: public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: gojs-angular.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.DataSyncService = DataSyncService;
    exports.DiagramComponent = DiagramComponent;
    exports.GojsAngularModule = GojsAngularModule;
    exports.OverviewComponent = OverviewComponent;
    exports.PaletteComponent = PaletteComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=gojs-angular.umd.js.map
